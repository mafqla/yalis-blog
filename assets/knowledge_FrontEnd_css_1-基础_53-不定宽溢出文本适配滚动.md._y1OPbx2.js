import{_ as n,c as t,o as l,V as a,m as s,a as i}from"./chunks/framework.bW6FiXxS.js";const h="/assets/88409639-cc8b5e00-ce07-11ea-8faa-77f7c4842f16.agHGHat0.png",p="/assets/88410932-a5ce2700-ce09-11ea-9f43-8bbfddf3918a.NNgBM5mR.png",e="/assets/88412686-871d5f80-ce0c-11ea-9649-becdae112f30.QEDt_rEO.gif",k="/assets/88413763-52120c80-ce0e-11ea-8b0e-7e4e546c1e49.kIc_U2he.png",w=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/FrontEnd/css/1-基础/53-不定宽溢出文本适配滚动.md","filePath":"knowledge/FrontEnd/css/1-基础/53-不定宽溢出文本适配滚动.md","lastUpdated":1712628282000}'),r={name:"knowledge/FrontEnd/css/1-基础/53-不定宽溢出文本适配滚动.md"},B=a('<p>在日常布局当中，肯定经常会遇到文本内容超过容器的情况。非常常见的一种解决方案是超出省略。</p><p>但是，有的时候，由于场景的限制，可能会出现在一些无法使用超出打点省略的方法的场景，譬如在导航栏中：</p><p><img src="'+h+`" alt="image" loading="lazy"></p><p>这种情况下，在容器定宽但是文本又溢出且不能换行的情况下，我们就需要寻求另外的解决方案。</p><h2 id="hover-时弹出框提示" tabindex="-1">hover 时弹出框提示 <a class="header-anchor" href="#hover-时弹出框提示" aria-label="Permalink to &quot;hover 时弹出框提示&quot;">​</a></h2><p>一种可行的方案是在 hover 的时候，弹出一个文本框展示全文，最简单的就是在文本标签下添加 title 属性，填充我们需要的内容：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code"><code><span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&lt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">nav</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  &lt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">p</span><span style="--shiki-light:#D19A66;--shiki-dark:#C792EA;"> title</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;">溢出文本1 溢出文本2 溢出文本3 溢出文本4</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#BABED8;">    溢出文本1 溢出文本2 溢出文本3 溢出文本4</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  &lt;/</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">p</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&lt;/</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">nav</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span></code></pre></div><p><img src="`+p+'" alt="image" loading="lazy"></p><p>当然，这种方法简单但是可能缺乏点用户体验。</p><hr><p>本文将简单介绍在文本长度不确定，容器长度也不确定的情况下，任意长度的文本实现 hover 状态下，从左向右，滚动到文本末端，再滚动回初始位置，如此反复，像是这样：</p><p><img src="'+e+`" alt="textscroll" loading="lazy"></p><h2 id="容器定宽-文本不定宽" tabindex="-1">容器定宽，文本不定宽 <a class="header-anchor" href="#容器定宽-文本不定宽" aria-label="Permalink to &quot;容器定宽，文本不定宽&quot;">​</a></h2><p>我们先假设一下，我们的容器的宽度如果是固定的，但是不确定每条文本的宽度。</p><p>像是这样：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code"><code><span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&lt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">div</span><span style="--shiki-light:#D19A66;--shiki-dark:#C792EA;"> class</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;">wrap</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  &lt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">p</span><span style="--shiki-light:#D19A66;--shiki-dark:#C792EA;"> title</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;">我的宽度是正常宽度</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#BABED8;">我的宽度是正常宽度</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&lt;/</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">p</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  &lt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">p</span><span style="--shiki-light:#D19A66;--shiki-dark:#C792EA;"> class</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;">scroll</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#D19A66;--shiki-dark:#C792EA;"> title</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;">我的宽度是溢出了一小部分</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#BABED8;">    我的宽度是溢出了一小部分</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  &lt;/</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">p</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  &lt;</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">p</span><span style="--shiki-light:#D19A66;--shiki-dark:#C792EA;"> class</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;">scroll</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#D19A66;--shiki-dark:#C792EA;"> title</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;">我的宽度是溢出了溢出了很大一部分</span><span style="--shiki-light:#98C379;--shiki-dark:#89DDFF;">&quot;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#BABED8;">    我的宽度是溢出了溢出了很大一部分</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  &lt;/</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">p</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&lt;/</span><span style="--shiki-light:#E06C75;--shiki-dark:#F07178;">div</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">&gt;</span></span></code></pre></div><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code"><code><span class="line"><span style="--shiki-light:#D19A66;--shiki-dark:#89DDFF;">.</span><span style="--shiki-light:#D19A66;--shiki-dark:#FFCB6B;">wrap</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    position</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> relative</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    width</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 150</span><span style="--shiki-light:#E06C75;--shiki-dark:#F78C6C;">px</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    overflow</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> hidden</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#FFCB6B;">p</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">     white-space</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> nowrap</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">}</span></span></code></pre></div><h3 id="使用-inline-block-获取实际文本的宽度" tabindex="-1">使用 <code>inline-block</code> 获取实际文本的宽度 <a class="header-anchor" href="#使用-inline-block-获取实际文本的宽度" aria-label="Permalink to &quot;使用 \`inline-block\` 获取实际文本的宽度&quot;">​</a></h3><p>由于 <code>&lt;p&gt;</code> 标签的宽度为父元素的 100%，如果是这样，我们很难进行下面的操作。我们首先需要拿到实际文本的宽度，这里可以借助 <code>inline-block</code> 的特性，做到这一点，我们改进下我们的 CSS：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code"><code><span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#FFCB6B;">p</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#BABED8;"> +  </span><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">display</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> inline-block</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    white-space</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> nowrap</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">}</span></span></code></pre></div><p>这样，当前 <code>&lt;p&gt;</code> 标签的实际宽度，其实就是整个文本元素的宽度。</p><p><img src="`+k+`" alt="image" loading="lazy"></p><blockquote><p>Tips：这里没有使用 <code>display: inline</code> 是因为下文我们需要让 p 元素滚动起来需要用到 transform，但是 transform 是无法作用在内联元素之上的。具体可以参考规范：<a href="https://drafts.csswg.org/css-transforms-1/#transformable-element" target="_blank" rel="noreferrer">transformable element</a></p></blockquote><h3 id="算出滚动距离-进行滚动" tabindex="-1">算出滚动距离，进行滚动 <a class="header-anchor" href="#算出滚动距离-进行滚动" aria-label="Permalink to &quot;算出滚动距离，进行滚动&quot;">​</a></h3><p>这样，我们有了父元素的宽度 <code>150px</code>，文本的宽度。那么很容易得到需要滚动的距离：</p><p><strong>需要滚动的距离 S = 溢出的文本元素的宽度 - 父元素的宽度</strong></p><p>这样，我们只需要找到一个可以表示并且当前文本宽度是变量值即可。即是 -- <strong>transoform</strong>。</p><p>由于在使用 transform: translate() 进行位移的时候，如果使用百分比表示，那么百分比的基准元素是元素本身，也就是如果我们 <code>transform: translate(100%, 0)</code>，其实表示的就是向右移动一个元素本身宽度的距离。</p><p>那么我们可以借助 calc 非常容易的拿到我们上述的需要滚动的距离 S -- <code>transform: translate(calc(-100% + 150px), 0)</code>，嵌入动画中：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code"><code><span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#FFCB6B;">p</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#56B6C2;--shiki-dark:#C792EA;">hover</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">  animation</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> move</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 1.5</span><span style="--shiki-light:#E06C75;--shiki-dark:#F78C6C;">s</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> infinite</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> alternate</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> linear</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#89DDFF;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">@keyframes</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> move</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#FFCB6B;">  0%</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    transform</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#56B6C2;--shiki-dark:#82AAFF;"> translate</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">(</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">0</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">,</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 0</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">);</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  }</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#FFCB6B;">  100%</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    transform</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#56B6C2;--shiki-dark:#82AAFF;"> translate</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">(</span><span style="--shiki-light:#56B6C2;--shiki-dark:#82AAFF;">calc</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">(</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">-100</span><span style="--shiki-light:#E06C75;--shiki-dark:#F78C6C;">%</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;"> +</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 150</span><span style="--shiki-light:#E06C75;--shiki-dark:#F78C6C;">px</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">),</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 0</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">);</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  }</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">}</span></span></code></pre></div><p>至此，对于任意超出容器宽度的文本，我们都可以轻松的完成上述的效果。</p>`,31),F=s("iframe",{height:"300",style:{width:"100%"},scrolling:"no",title:"不定长宽度文字跑马灯来回滚动展示 -- 父容器定宽，子元素不定宽",src:"https://codepen.io/mafqla/embed/qBvmGJM?default-tab=html%2Cresult&editable=true&theme-id=light",frameborder:"no",loading:"lazy",allowtransparency:"true",allowfullscreen:"true"},`
  See the Pen <a href="https://codepen.io/mafqla/pen/qBvmGJM">
  不定长宽度文字跑马灯来回滚动展示 -- 父容器定宽，子元素不定宽</a> by mafqla (<a href="https://codepen.io/mafqla">@mafqla</a>)
  on <a href="https://codepen.io">CodePen</a>.
`,-1),d=a(`<h2 id="父容器不定宽度" tabindex="-1">父容器不定宽度 <a class="header-anchor" href="#父容器不定宽度" aria-label="Permalink to &quot;父容器不定宽度&quot;">​</a></h2><p>当然，还没完。</p><p>如果父容器的宽度也是不固定的，或因为者 <code>calc</code> 兼容性问题无法使用上述方法。那么，我们要做的就是，在一段固定的 CSS 代码中，既能运动当前元素的宽度，也能位移父容器的宽度。</p><p>正巧，CSS 还真能完成上述要求，我们改造一下 <code>animation</code> 的代码：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code"><code><span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#89DDFF;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">@keyframes</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> move</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#FFCB6B;">  0%</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    left</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 0</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    transform</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#56B6C2;--shiki-dark:#82AAFF;"> translate</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">(</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">0</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">,</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 0</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">);</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  }</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#FFCB6B;">  100%</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    left</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 100</span><span style="--shiki-light:#E06C75;--shiki-dark:#F78C6C;">%</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    transform</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#56B6C2;--shiki-dark:#82AAFF;"> translate</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">(</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">-100</span><span style="--shiki-light:#E06C75;--shiki-dark:#F78C6C;">%</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">,</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 0</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">);</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">  }</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">}</span></span></code></pre></div><ul><li><code>transform: translate(-100%, 0)</code> 能够向左位移<strong>自身宽度</strong>的 100%</li><li><code>left: 100%</code> 能够实现向右位移<strong>父容器宽度</strong>的 100%</li></ul><blockquote><p>使用 <code>margin-left</code> 替换 <code>left</code> 也是一样可以实现的，使用百分比表示的 <code>margin-left</code> 位移的基准也是父元素的宽度。</p></blockquote><p>这样，不论父容器宽度如何，文本元素宽度如何，都可以实现对溢出文本适配滚动展示。</p>`,8),o=s("iframe",{height:"300",style:{width:"100%"},scrolling:"no",title:"不定宽文字跑马灯来回滚动展示 -- 父容器不定宽，子元素不定宽",src:"https://codepen.io/mafqla/embed/dyrWEgw?default-tab=html%2Cresult&editable=true&theme-id=light",frameborder:"no",loading:"lazy",allowtransparency:"true",allowfullscreen:"true"},`
  See the Pen <a href="https://codepen.io/mafqla/pen/dyrWEgw">
  不定宽文字跑马灯来回滚动展示 -- 父容器不定宽，子元素不定宽</a> by mafqla (<a href="https://codepen.io/mafqla">@mafqla</a>)
  on <a href="https://codepen.io">CodePen</a>.
`,-1),D=s("h2",{id:"部分不足之处",tabindex:"-1"},[i("部分不足之处 "),s("a",{class:"header-anchor",href:"#部分不足之处","aria-label":'Permalink to "部分不足之处"'},"​")],-1),g=s("ol",null,[s("li",null,"无法判断文本长度是否超出父元素宽度")],-1),c=s("p",null,"当然，上述方案并非完美的方案，如果我们希望只针对本文长度溢出的情况，hover 的时候才进行滚动，这一点在使用纯 CSS 的情况下是无法实现的。",-1),y=s("p",null,"我们无法通过 CSS 去判断当前元素长度是否大于父元素长度再选择性的进行动画。毕竟 CSS 只是负责样式，不控制行为。所以实际使用中，可能还是需要借助 JavaScript 简单判断，然后通过一个 class 进行控制。",-1),A=s("ol",null,[s("li",null,"动画闪烁")],-1),C=s("p",null,[i("在"),s("strong",null,"父容器不定宽度"),i("的情况下，由于需要同时对两个属性进行动画，并且位移的方向是相反的，所以动画看上去会有一点闪烁。这个暂时没有找到特别好的解决方案。")],-1),m=[B,F,d,o,D,g,c,y,A,C];function f(_,u,E,b,v,q){return l(),t("div",null,m)}const P=n(r,[["render",f]]);export{w as __pageData,P as default};
